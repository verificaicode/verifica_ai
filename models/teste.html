<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <title>TF-IDF + SVD + TFLite inferência</title>
  <script src="https://cdn.jsdelivr.net/npm/js-md5@0.7.3/build/md5.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-tflite"></script>
</head>
<body>

<textarea id="inputText" rows="6" cols="60" placeholder="Digite o texto aqui..."></textarea><br/>
<button id="btnRun">Verificar</button>

<pre id="output"></pre>

<script>
(async () => {
  tflite.setWasmPath('https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-tflite@0.0.1-alpha.8/dist/');

  // Carrega vocabulário e idf
  const vocabResponse = await fetch('tfidf_hashed_vocab_svd.json');
  const vocabData = await vocabResponse.json();

  // Dados
  const hashedVocab = vocabData.vocabulary; // [[hash, idx], ...]
  const idfArray = vocabData.idf; // [idf...]
  const svdComponents = vocabData.svd_components;

  // Criar dicionário hash->idx para busca rápida
  const hashToIndex = new Map();
  hashedVocab.forEach(([hash, idx]) => hashToIndex.set(hash, idx));

  // Carregar modelo tflite
  const tfliteModel = await tflite.loadTFLiteModel('is_fact_model.tflite');

  // Função para tokenizar texto em palavras (simplificado)
  function tokenize(text) {
    return text.toLowerCase().match(/\w+/g) || [];
  }

  // Função hash MD5 para palavra retornando 32bit number (8 primeiros hex chars)
  function hashWord(word) {
    const hex = md5(word);
    return parseInt(hex.substring(0, 8), 16);
  }

  // Função que gera vetor TF-IDF esparso a partir do texto
  function computeTFIDFVector(words) {
    const termCounts = new Map();
    words.forEach(w => {
      const h = hashWord(w);
      if (hashToIndex.has(h)) {
        termCounts.set(h, (termCounts.get(h) || 0) + 1);
      }
    });

    const totalTerms = words.length || 1;
    const vector = new Array(idfArray.length).fill(0);

    termCounts.forEach((count, h) => {
      const idx = hashToIndex.get(h);
      const tf = count / totalTerms; // frequência relativa
      const idf = idfArray[idx];
      vector[idx] = tf * idf;
    });

    // Normalizar vetor TF-IDF (L2 norm)
    const norm = Math.sqrt(vector.reduce((sum, v) => sum + v*v, 0)) || 1;
    return vector.map(v => v / norm);
  }

  function applySVD(tfidfVector) {
        const result = [];
        for (let i = 0; i < svdComponents.length; i++) {
            let sum = 0;
            for (let j = 0; j < tfidfVector.length; j++) {
                sum += svdComponents[i][j] * tfidfVector[j];
            }
            result.push(sum);
        }
        return result;
    }

    function argMax(arr) {
        return arr.reduce((bestIdx, val, idx, array) => val > array[bestIdx] ? idx : bestIdx, 0);
    }

    // Função para executar inferência TFLite
    async function runInference(tfidfVector) {
        return tf.tidy(() => {
            const inputTensor = tf.tensor(tfidfVector, [1, tfidfVector.length], 'float32');
            const outputTensor = tfliteModel.predict(inputTensor);
            return outputTensor.dataSync();

        });
    }

  // Manipulador botão
  document.getElementById('btnRun').onclick = async () => {
    const text = document.getElementById('inputText').value;
    const words = tokenize(text);

    const inicio = performance.now();

    const tfidfVector = computeTFIDFVector(words);

    const svdVector = applySVD(tfidfVector)
    const value = await runInference(svdVector);

    const fim = performance.now();
    const duracao = fim - inicio;

    const is_fact_class = argMax(value);
    const result = is_fact_class == 2 ? "Fato" : is_fact_class == "1" ? "Indeterminado" : "Fake";
    document.getElementById('output').textContent = `Probabilidade de cada classe (Fake, Indeterminado, Fato):\n[${value.map(v => v.toFixed(5)).join(', ')}]\nresultado: ${result}\nTempo de execução: ${duracao.toFixed(2)} ms`;
  };

})();
</script>
</body>
</html>
